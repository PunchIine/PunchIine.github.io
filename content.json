{"pages":[],"posts":[{"title":"Git学习笔记","text":"git init —— 初始化一个Git仓库 git add —— 添至暂存区 git commit —— 提交 git push —— 上传远程代码并合并 git pull —— 下载远程代码并合并 git clone —— 从现有Git仓库中拷贝项目 git config —— 配置信息 git status —— 查看仓库当前的状态 显示有变更的文件 git diff —— 比较文件的不同，即暂存区和工作区的差异 git reset —— 用于回退版本， 可以制定退回某一次提交的版本 git rm —— 将文件从暂存区和工作区中删除 git mv —— 用于移动或重命名一个文件,目录或软连接。 git log —— 查看历史提交记录 git remote —— 远程仓库操作 git branch (branchname) —— 创建新分支 git checkout (branchname) —— 切换分支命令 git merge —— 合并分支命令 git fetch —— 从远程获取代码库 git tag [tagname]—— 为提交快照打上标签 生成ssh密钥 git init —— 初始化一个Git仓库 执行后会生成一个.git目录， 该目录包含了资源的所有元数据 使用指定目录作为git仓库 ——git init newrepo 执行后会在newrepo目录下生成.git目录 将文件纳入版本控制 git add —— 添至暂存区git add . —— 将当前目录下所有未纳入的文件添加到暂存区 git add {文件名} —— 将指定文件添加到暂存区 git commit —— 提交git commit -m ‘提交说明’ —— 对暂存区中的文件进行提交（添加到仓库中） git push —— 上传远程代码并合并git push 命用于从将本地的分支版本上传到远程并合并。 命令格式如下： 1git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 若远程分支名与本地分支名相同则可以省略：及之后部分 若版本有差异，想要强制推送 1git push --force &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 若要删除主机的分支 1git push origin --delete master # 表示删除origin主机的master分支 git pull —— 下载远程代码并合并git pull 命令用于从远程获取代码并合并本地的版本。 git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。 命令格式如下： 1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; git clone —— 从现有Git仓库中拷贝项目git clone or git clone ——克隆到指定目录 如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字 git commit -a 跳过git add，直接添加至暂存区后提交 git config —— 配置信息git config –list —— 显示当前的git配置信息 git config -e —— 针对当前仓库编辑git配置文件 git config -e –global —— 针对系统上所有仓库 设置提交代码时的用户信息： git config –global user.name {YOURGITHUBNAME}git config –global user.email {YOUREMAIL} git status —— 查看仓库当前的状态 显示有变更的文件git status -s 获得更简短的输出结果 git diff —— 比较文件的不同，即暂存区和工作区的差异 尚未缓存的改动：git diff 查看已缓存的改动： git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff –stat git reset —— 用于回退版本， 可以制定退回某一次提交的版本1git reset [--soft | --mixed | --hard] [HEAD] git reset HEAD^ - 回退所有内容到上一个版本 git reset HEAD^ {filename} - 回退指定文件到上一个版本 git reset {版本号} - 回退到指定版本 git reset –soft HEAD – soft参数用于回退到某个版本 例： 1$ git reset --soft HEAD~3 # 回退上上上一个版本 git reset –hard HEAD –hard 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交（慎重使用） HEAD 说明： HEAD 表示当前版本 HEAD^ 上一个版本 HEAD^^ 上上一个版本 HEAD^^^ 上上上一个版本 以此类推… 可以使用 ～数字表示 HEAD~0 表示当前版本 HEAD~1 上一个版本 HEAD^2 上上一个版本 HEAD^3 上上上一个版本 以此类推… git reset HEAD 命令用于取消已缓存的内容。 git rm —— 将文件从暂存区和工作区中删除如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f git rm -f 如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可： git rm –cached git mv —— 用于移动或重命名一个文件,目录或软连接。git mv [file] [newfile] git log —— 查看历史提交记录用 –online 选项来查看历史记录的简洁版本。 git log –online git blame - 以列表形式查看指定文件的历史修改记录 git remote —— 远程仓库操作git remote -v —— 显示所有远程仓库 git remote show [remote] —— 显示某个远程仓库的信息 remote为远程仓库地址 git remote set-url [shortname] [url] shortname 为本地的版本库 添加远程版本库： git remote add [shortname] [url] shortname 为本地的版本库 git remote rm name # 删除远程仓库git remote rename old_name new_name # 修改仓库名 git branch (branchname) —— 创建新分支git branch —— 列出本地的分支 git checkout (branchname) —— 切换分支命令当切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 也可以使用 git checkout -b (branchname) —— 创建新分支并立即切换到该分支下，从而在该分支中操作。 git merge —— 合并分支命令git merge [branchname] —— 将指定分支与当前所在分支合并 git fetch —— 从远程获取代码库执行完后执行git merge合并远程分支到你所在的分支 git tag [tagname]—— 为提交快照打上标签例： 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签 git tag —— 查看所有标签 -a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 git log –decorate —— 查看标签 生成ssh密钥执行： 1ssh-keygen -t rsa -C &lt;your email&gt; 会生成一个.ssh文件 找到其中的id_rsa.pub将其中内容复制 进入github settings 点击SSH and GPG keys 创建新密钥并将密钥内容粘贴入其中","link":"/2022/04/10/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Json学习笔记","text":"JSON JSON 语法规则 JSON 名称/值对 JSON 值 JSON 文件 JSON对象 使用点号访问对象值 使用点号. 或者中括号 [] 来访问嵌套的JSON对象。 修改JSON值 修改对象属性 JSON数组 数组可以作为JSON对象 JSON对象中的数组 嵌套 JSON 对象中的数组 Python json json.dumps json.loads JSONJSON: JavaScript Object Notation(JavaScript 对象表示法) JSON 语法规则JSON 语法是 JavaScript 对象表示语法的子集。 数据在名称/值对中 数据由逗号分隔 大括号 {} 保存对象 中括号 [] 保存数组，数组可以包含多个对象 JSON 名称/值对JSON 数据的书写格式是： 1key : value 名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值： “name” : “菜鸟教程” JSON 值JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在中括号中） 对象（在大括号中） null JSON 文件 JSON 文件的文件类型是 .json JSON 文本的 MIME 类型是 application/json MINE类型：媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。 它在IETF RFC 6838中进行了定义和标准化。 JSON对象必须在大括号{}中书写， key必须是字符串，value可以是合法的JSON数据类型（见JSON值） 使用点号访问对象值例： 123var myobj, x;myobj = {&quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null};x = myobj[&quot;name&quot;]; 使用点号. 或者中括号 [] 来访问嵌套的JSON对象。12x = myobj.sites.site1;x = myobj.sites[&quot;site1&quot;]; 修改JSON值使用点号访问并修改 1myobj.sites.site1 = &quot;sxasxaxa&quot; 使用中括号访问并修改 1myobj.sites.[&quot;site1&quot;] = &quot;sadadsad&quot; 修改对象属性使用delete关键字来删除JSON对象的属性： 1delete myobj.sites.site1 JSON数组数组可以作为JSON对象例： 1[ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot; ] JSON对象中的数组例： 12345{&quot;name&quot;:&quot;网站&quot;,&quot;num&quot;:3,&quot;sites&quot;:[ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot; ]} 嵌套 JSON 对象中的数组JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象： 例： 123456789myObj = { &quot;name&quot;:&quot;网站&quot;, &quot;num&quot;:3, &quot;sites&quot;: [ { &quot;name&quot;:&quot;Google&quot;, &quot;info&quot;:[ &quot;Android&quot;, &quot;Google 搜索&quot;, &quot;Google 翻译&quot; ] }, { &quot;name&quot;:&quot;Runoob&quot;, &quot;info&quot;:[ &quot;菜鸟教程&quot;, &quot;菜鸟工具&quot;, &quot;菜鸟微信&quot; ] }, { &quot;name&quot;:&quot;Taobao&quot;, &quot;info&quot;:[ &quot;淘宝&quot;, &quot;网购&quot; ] } ]} ————JSON数组和对象都可以使用for-in循环来访问 Python jsonjson.dumps1json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw) ——将python对象编码成JSON字符串 123456import jsondata = [ { 'a' : 1, 'b' : 2, 'c' : 3, 'd' : 4, 'e' : 5 } ]data2 = json.dumps({'a': 'Runoob', 'b': 7}, sort_keys=True, indent=4, separators=(',', ': '))print(data2) json.loads1json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]]) ——json.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。 123456import jsonjsonData = '{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5}';text = json.loads(jsonData)print(text)","link":"/2022/04/10/Json%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"baseline","text":"VGG VGGVGG 网络结构 因为只使用了3x3卷积核， 尽管深度很大，网络中的权重数量相较具有更大卷积层宽度和感受野的网络并不大。 3×3卷积的使用 图为两个3×3卷积核的堆叠 1.可见两个3×3卷积核堆叠在原feature map中的感受野与一个5×5卷积核相同， 三个3x3的堆叠卷基层的感受野是7x7 2.可以把三个3x3的filter看成是一个7x7filter的分解中间层有非线性的分解, 并且起到隐式正则化的作用。 3.使用小卷积核减少了参数数量： 假设该卷积层的卷积核为3×3，为了清晰明了假设卷积层的输入和输出的特征图（featuremap）大小（其实是channel通道数）分别为C1，C2。说明：卷积核的应该是一个多维的矩阵K×K×channels，其中channels是由输入的featuremap的通道数决定的，而卷积层中卷积核的个数是由输出的featuremap的通道数决定的。所以该卷积层的参数量是：（3×3×C1）× C2说明:（3×3×C1） —— 是每一个卷积核的参数量（输入） × C2 —— 是总共C2个卷积核（输出的通道数）","link":"/2022/04/27/baseline/"},{"title":"jetson配置日志","text":"jetson nano apt更换国内源备份source.list文件 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 修改source.list文件 1sudo vim /etc/apt/sources.list 删除所有内容，并复制： 12345678deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main multiverse restricted universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main multiverse restricted universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main multiverse restricted universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main multiverse restricted universe 注意arm架构下的apt源与普通的ubuntu不相同 then 12sudo apt-get updatesudo apt-get upgrade jtop安装先安装pip 1sudo apt-get install python3-pip then 1sudo pip3 install jetson-stats -i https://pypi.tuna.tsinghua.edu.cn/simple 1sudo jtop # 打开jtop zerotier安装使用（内网穿透）安装命令 1curl -s https://install.zerotier.com | sudo bash 加入网络 1sudo zerotier-cli join xxxxxxxxxxxxxxxx 离开网络 1sudo zerotier-cli leave xxxxxxxxxxxxxxxx 启动 1sudo systemctl start zerotier-one.service 设置开机自启 1sudo systemctl enable zerotier-one.service minifoege 安装https://github.com/conda-forge/miniforge 在jetson nano中选择Mambaforge时 出现了pip 无法使用 illegal instruction(core dumped) 的问题 安装miniforge后在虚拟环境中出现同样问题， 但能在base环境下正常使用pip 所以选择使用它 在Miniforge-Linux-aarch64.sh所在文件夹打开终端 执行 1bash Miniforge-Linux-aarch64.sh 全yes即可 conda更换国内镜像源配置清华源： 12345conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/#设置搜索时显示通道地址conda config --set show_channel_urls yes 可执行conda config –show channels显示已添加的源 pip更换国内镜像源编辑pip配置文件： 12mkdir ~/.pipvim ~/.pip/pip.conf 添加内容为： 1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn conda更改base环境下python版本1conda install python=&lt;版本号&gt; （看网上都是这么干的， 但由于我们想换版本时已经无意中在base环境下下载了很多包， 所以由于依赖问题这样会报错） 1conda clean -a # 删除所有包 jetson nano 和 jetson nx 配置 cudajetson nano 与 nx 已经内置好了cuda， 但需要配置环境变量才能使用 1vim ~/.bashrc 在.bashrc文件中添加： 1234export PATH=/usr/local/cuda-10.2/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATHexport CUDA_HOME=/usr/local/cuda-10.2export OPENBLAS_CORETYPE=ARMV8 # 据说不加的话，运行相关的项目会内核崩掉（but在我配置nano环境时即使加上也无济于事） 再次执行： 1source ~/.bashrc 最后输入nvcc -V 测试环境变量是否设置正确 cv2, torch等由于numpy问题报错illegal instruction(core dumped)我们下载的numpy版本是1.19.5 在base环境中测试了几个版本发现都没有问题 于是换了个numpy版本就解决了（大概是1.19.5版本的numpy在arm架构下出了点问题） 在linux下使用opencv无法打开摄像头问题[ WARN:0] global /io/opencv/modules/videoio/src/cap_v4l.cpp (893) open VIDEOIO(V4L2:/dev/video0): can’t open camera by index发现是重复调用摄像头导致的： 两次使用了cv2.VideoCapture(0) 删去一个就可以了 除此之外还遇到了另一个报错令代码无法运行（忘记记录了），原因是opencv版本太高， 降了几个版本就解决了 报错This plugin does not support propagateSizeHints()， 图形界面控件消失网上的解决方案都奇奇怪怪的（我看不明白） 在使用管理员权限运行代码后神奇的成功了 sudo python main.py pyside2的安装在网上没有找到支持arm架构的pyside2 whl安装包 所以我们自己编译了pyside2 dlib安装torch和torchvision的安装","link":"/2022/04/16/jetson%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97/"},{"title":"pytorch笔记","text":"一.张量1.张量的数据类型 默认数据类型为32位浮点型 **torch.set_default_tensor_type()**函数可设置默认的张量数据类型 a.long() a.int() a.float()方法 2.张量的生成(1)列表或序列可通过**torch.tensor()**函数构造张量 **.shape .size .numel()**方法 1234567a = torch.randn((2,3,5),dtype = torch.float32)print(a.shape)#打印“torch.Size([2,3,5])”不需要加括号，直接访问成员属性，返回的是torch.Size类对象，print(a.shape[1])#可以使用[]索引访问,所以size属性是一个迭代器print(a.size())#打印“torch.Size([2,3,5])”,与shape属性一致print(a.size(1))#可传入参数，返回3，即第i维的个数print(a.numel)#返回30，计算张量中包含元素数量 通过torch.tensor()函数构造张量可使用dtype参数指定数据类型，使用requires_grad来指定是否需要计算梯度 (2)**torch.Tensor()**——————一个类 可以生成指定形状的张量 (3)torch.from_numpy(ndarray) torch.as_tensor() (4)依据数值创建 **torch.empty()**————返回填充有未初始化数据的张量，张量的形状由可变的参数大小定义 1234&gt;&gt;&gt; torch.empty(2, 3)tensor(1.00000e-08 * [[ 6.3984, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000]]) (5)依据概率分布创建张量 **torch.manual_seed()**——————指定生成随机数种子 3.张量的操作（1）张量的拼接与切分 **torch.stack()**会拓展张量维度 （2）张量索引 ==注意index参数的数据类型必须是torch.long== 例 (对第0维度进行索引（相当于索引第一维度）) （3）张量变换 ==注意reshape共享数据内存== 如图： 沿着指定的维度重复tensor。不同与expand()，本函数复制的是tensor中的数据。扩展（expand）张量不会分配新的内存，只是在存在的张量上创建一个新的视图（view），一个大小（size）等于1的维度扩展到更大的尺寸。repeat沿着特定的维度重复这个张量，和expand()不同的是，这个函数拷贝张量的数据。 （4）张量数学运算 真多啊。。。用到再查叭。 二.pytorch中的自动求导将张量的requires_grad参数设为Ture可自动求导得到其梯度 Tensor()类的重要属性： 在Pytorch中，默认情况下，非叶节点的梯度值在反向传播过程中使用完后就会被清除，不会被保留。只有叶子节点的梯度值能够被保留下来 retain_grad()可保存非叶子节点梯度 grad_fn：记录创建该张量时所用的方法（函数） 123print(&quot;grad_fn:&quot;, w.grad_fn, x.grad_fn, a.grad_fn, b.grad_fn, y.grad_fn)# Out：grad_fn: None None &lt;AddBackward0 object at 0x000001C04BB24788&gt; &lt;AddBackward0 object at 0x000001C04605D188&gt; &lt;MulBackward0 object at 0x000001C04605D1C8&gt; autogradtorch.autograd.backward张量中的backward()方法直接调用了torch.autograd.backward() retain_graph参数设置为True，得以进行两次反向传播 grad_tensors参数用于多梯度权重的设置 123456789101112131415161718w = torch.tensor([1.], requires_grad=True) x = torch.tensor([2.], requires_grad=True) a = torch.add(w, x) # retain_grad() b = torch.add(w, 1) y0 = torch.mul(a, b) # y0 = (x+w) * (w+1) y1 = torch.add(a, b) # y1 = (x+w) + (w+1) dy1/dw = 2 loss = torch.cat([y0, y1], dim=0) # [y0, y1] grad_tensors = torch.tensor([1., 1.]) # grad_tensors = torch.tensor([1., 2.]) loss.backward(gradient=grad_tensors) # gradient 传入 torch.autograd.backward()中的grad_tensors print(w.grad) out：7 # 9 torch.autograd.grad create_graph 创建导数计算图，用于高阶求导 autograd小贴士：1.梯度不自动清零 使用grad.zero_() 对梯度清零 2.依赖于叶子节点的节点， requires_grad默认为True 3.叶子节点不可执行in-place操作 可知+=操作时不改变内存地址，为in-place操作，不可对叶子节点执行 三.torch.nn模块容器 卷积层 123456789# 以torch.nn.Conv2d()为例， 介绍卷积再图像上的使用方法，其调用方式为：torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True) 123456789101112131415161718192021222324252627282930import numpy as npimport torchimport torch.nn as nnimport matplotlib.pyplot as pltfrom PIL import Imagemyim = Image.open(&quot;lenna.jpg&quot;)myimgray = np.array(myim.convert(&quot;L&quot;), dtype=np.float32)imh, imw = myimgray.shapemyimgray_t = torch.from_numpy(myimgray.reshape((1, 1, imh, imw)))kersize = 5ker = torch.ones(kersize, kersize, dtype=torch.float32)*-1ker[2, 2] = 24ker = ker.reshape((1, 1, kersize, kersize))conv2d = nn.Conv2d(1, 2, (kersize, kersize), bias = False)conv2d.weight.data[0] = kerimconv2dout = conv2d(myimgray_t)imconv2dout_im = imconv2dout.data.squeeze()plt.figure(figsize=(12, 6))plt.imshow(imconv2dout_im[0], cmap=plt.cm.gray)plt.axis(&quot;off&quot;)plt.show() 可见使用边缘特征提取卷积核很好的提取出了图像的边缘信息 池化层 激活函数 全连接层 四.pytorch中的数据操作与预处理 Dataloader Dataset transforms crop flip rotation transforms的操作 自定义transforms 正态分布与平方损失接下来，我们通过对噪声分布的假设来解读平方损失目标函数。 正态分布和线性回归之间的关系很密切。 正态分布（normal distribution），也称为高斯分布（Gaussian distribution）， 最早由德国数学家高斯（Gauss）应用于天文学研究。 简单的说，若随机变量xx具有均值μμ和方差σ2σ2（标准差σσ），其正态分布概率密度函数如下： (3.1.11) p(x)=12πσ2−−−−√exp(−12σ2(x−μ)2).p(x)=12πσ2exp⁡(−12σ2(x−μ)2). 下面我们定义一个Python函数来计算正态分布。 123def normal(x, mu, sigma): p = 1 / math.sqrt(2 * math.pi * sigma**2) return p * np.exp(-0.5 / sigma**2 * (x - mu)**2) 我们现在可视化正态分布。 12345678# 再次使用numpy进行可视化x = np.arange(-7, 7, 0.01)# 均值和标准差对params = [(0, 1), (0, 2), (3, 1)]d2l.plot(x, [normal(x, mu, sigma) for mu, sigma in params], xlabel='x', ylabel='p(x)', figsize=(4.5, 2.5), legend=[f'mean {mu}, std {sigma}' for mu, sigma in params]) 就像我们所看到的，改变均值会产生沿xx轴的偏移，增加方差将会分散分布、降低其峰值。 均方误差损失函数（简称均方损失）可以用于线性回归的一个原因是： 我们假设了观测中包含噪声，其中噪声服从正态分布。 噪声正态分布如下式: (3.1.12) y=w⊤x+b+ϵ,y=w⊤x+b+ϵ, 其中，ϵ∼N(0,σ2)ϵ∼N(0,σ2)。 因此，我们现在可以写出通过给定的xx观测到特定yy的似然（likelihood）： (3.1.13) P(y∣x)=12πσ2−−−−√exp(−12σ2(y−w⊤x−b)2).P(y∣x)=12πσ2exp⁡(−12σ2(y−w⊤x−b)2). 现在，根据极大似然估计法，参数ww和bb的最优值是使整个数据集的似然最大的值： (3.1.14) P(y∣X)=∏i=1np(y(i)|x(i)).P(y∣X)=∏i=1np(y(i)|x(i)). 根据极大似然估计法选择的估计量称为极大似然估计量。 虽然使许多指数函数的乘积最大化看起来很困难， 但是我们可以在不改变目标的前提下，通过最大化似然对数来简化。 由于历史原因，优化通常是说最小化而不是最大化。 我们可以改为最小化负对数似然−logP(y∣X)−log⁡P(y∣X)。 由此可以得到的数学公式是： (3.1.15) −logP(y∣X)=∑i=1n12log(2πσ2)+12σ2(y(i)−w⊤x(i)−b)2.−log⁡P(y∣X)=∑i=1n12log⁡(2πσ2)+12σ2(y(i)−w⊤x(i)−b)2. 现在我们只需要假设σσ是某个固定常数就可以忽略第一项， 因为第一项不依赖于ww和bb。 现在第二项除了常数1σ21σ2外，其余部分和前面介绍的均方误差是一样的。 幸运的是，上面式子的解并不依赖于σσ。 因此，在高斯噪声的假设下，最小化均方误差等价于对线性模型的极大似然估计。","link":"/2022/04/24/pytorch%E7%AC%94%E8%AE%B0/"},{"title":"yolo","text":"IoU（Intersection over union） 交并比，衡量两个区域的重叠程度，是二者重叠部分面积占二者总面积的比例 在目标检测任务中，如果我们模型输出的矩形框与我们人工标注的矩形框的IoU值大于某个阈值时（通常为0.5）即认为我们的模型输出了正确的 Precision &amp; Recall假设我们有一组图片，里面有若干待检测的目标， Precision就代表我们模型检测出来的目标有多大比例是真正的目标物体， Recall就代表所有真实的目标有多大比例被我们的模型检测出来了。 TP ：模型预测为某类物品且与数据集标注中该类物品IOU大于0.5 TN ：模型预测不为某类物品但与数据集标注中该类物品IOU大于0.5 FP ：模型预测为某类物品，但与数据集标注中所有物品（包括非此类）IOU均大于0.5 FN ：模型预测不是任何一类物品，且与数据集中所有物品IOU均大于0.5 准确率： 模型检测出的物品中正确的比例 召回率： 所有正确的目标中被模型检测出来的比例 PR曲线 我们当然希望检测的结果P越高越好，R也越高越好，但事实上这两者在某些情况下是矛盾的。比如极端情况下，我们只检测出了一个结果，且是准确的，那么Precision就是100%，但是Recall就很低；而如果我们把所有结果都返回，那么必然Recall必然很大，但是Precision很低。 因此在不同的场合中需要自己判断希望P比较高还是R比较高。如果是做实验研究，可以绘制Precision-Recall曲线来帮助分析。 AP (Average Precision)AP = $\\int^1_0p(r)dr$ 在实际应用中，我们并不直接对该PR曲线进行计算，而是对PR曲线进行平滑处理。即对PR曲线上的每个点，Precision的值取该点右侧最大的Precision的值。 ？ Yolov1 将目标检测问题转化为一个回归问题进行求解，也就是说将图像作为输入（像素数据），直接输出物体的位置和所属于的类别的置信度（是以一个向量的形式表示的，后续会介绍），属于端到端的模型形式。 基本思想：将图片划分为S*S个区域（gridcell），假设都存在一个 true answer 也就是针对这个目标的最好的检测框 ， 则每一个目标的检测框的中心点一定是落在某一个小区域内的；如果此时的中心点落在 x 框内，则 x 小区域就负责搞定这个目标；注意此时可能多个目标落在同一个区域内。 每一个小区域设定 B （bounding box的数量）个可能的候选框，并计算每一个可能的候选框的得分 = 置信度，是一个（该候选框和真实的目标检测框的重合程度）和（这个框里确实框住了某一个物体）的综合度量指标，计算方式如下： $confidence = Pr（Object）* IOU^{truth}_{pred}$ 其中，若bounding box包含物体，则P(object) = 1；否则P(object) = 0 每一个预测是一个长度为 5 的向量，记作 （x, y, w, h, conf） (x, y) 表示当前预测的检测框的中心相对于我的小区域的位置（共 个小区域)，这里的 x 和 y 都是 0-1 之间的，也就是说是相对于当前小区域的左上角的偏移值 (w,h) 表示检测框的宽度和高度，一般是处理到 0-1 之间，标记当前的预测框和整个图片的宽度/高度的比例 - conf 为上述的置信度，可以看作是当前的框的可信度的综合指标，由（是否框准了 = 是否和真实的预测框有较好的重合）和（是否框里确实框住了物体）两个部分影响 网络结构 Our detection network has 24 convolutional layers followed by 2 fully connected layers. Alternating 1 × 1 convolutional layers reduce the features space from preceding layers. We pretrain the convolutional layers on the ImageNet classifification task at half the resolution (224 × 224 input image) and then double the resolution for detection. YOLO网络借鉴了GoogLeNet分类网络结构。 网络有24个卷积层，其后是2个完全连接的层，不同的是，YOLO未使用inception module，而是使用1x1卷积层（此处1x1卷积层的存在是为了跨通道信息整合）+3x3卷积层简单替代。最终输出的是7x7x30的张量的预测值 损失函数 使用均方和误差作为loss函数来优化模型参数，即网络输出的SxSx(Bx5 + C)维向量与真实图像的对应SxSx(Bx5 + C)维向量的均方和误差。 NMS 方法（Non-Maximal Suppression / 非极大值抑制） 将同一目标内的bboxes按照cls score + IoU阈值做筛选，剔除冗余地、低置信度的bbox Yolov3实际框 预测框 anchor box Anchor Box","link":"/2022/04/27/yolo/"},{"title":"OpenMV实现靶点检测","text":"—— 未完 idea: 初步想法是利用颜色信息对靶子进行检测 再对靶点进行定位。若效果不佳考虑部署TensorFlow Lite yolo进行目标检测 边缘检测 图像对比 先颜色识别后模块匹配 决定先色块识别定位靶子。舵机追踪靶子方位同时横向运动小车，令小车舵机与车身角度为90度时舵机对准靶子。转动小车使车身与舵机夹角为0度。使小车直行，并进行边缘检测，传回矩形靶子的长宽大小比例，分析数据并不断进行微调。戳中靶心后转动舵机寻找第二个靶子重复以上操做。 1.设置窗口roi 1sensor.set_windowing(roi) roi （回报率） （感兴趣的区域）（进行检测的区域） roi的格式是(x, y, w, h)的tupple 2.水平翻转图像，使小车视野与实际相同 水平方向翻转： 1sensor.set_hmirror(True) 3.获取区域内的平均颜色或者占面积最大的颜色信息 使用 Statistics 1image.get_statistics(roi=Auto) 4.寻找色块 1image.find_blobs(thresholds, roi=Auto, x_stride=2, y_stride=1, invert=False, area_threshold=10, pixels_threshold=10, merge=False, margin=0, threshold_cb=None, merge_cb=None) thresholds是颜色的阈值，注意：这个参数是一个列表，可以包含多个颜色。如果你只需要一个颜色，那么在这个列表中只需要有一个颜色值，如果你想要多个颜色阈值，那这个列表就需要多个颜色阈值。注意：在返回的色块对象blob可以调用code方法，来判断是什么颜色的色块。 阈值参数的结构 1colour = (minL, maxL, minA, maxA, minB, maxB) OpenMV 的IDE里加入了阈值选择工具 用他！ (50, 75, -60, -14, 12, 62)浅测一个绿色 感觉不是很准。。 靶点检测场地为200*200 调整x, y_stride 将merge设置为True blob.rect() 返回这个色块的外框——矩形元组(x, y, w, h) 边缘检测 image.find_edges(edge_type[,threshold]) 将图像变为黑白。边缘保留白色像素 edge_type 参数：image.EDGE_SIMPLE ——简单的阈值高通滤波算法 ​ image.EDGE_CANNY ——canny边缘检测 threshold —— 包含高低阈值的二元组 默认（100，200） 仅支持灰度图像 例程： 12345678910111213141516171819202122232425262728# Canny边缘检测:## 这个例子展示了Canny边缘检测。import sensor, image, timesensor.reset() # 初始化sensor.sensor.set_pixformat(sensor.GRAYSCALE) # or sensor.RGB565#设置图像色彩格式，有RGB565色彩图和GRAYSCALE灰度图两种sensor.set_framesize(sensor.QQVGA) # or sensor.QVGA (or others)#设置图像像素大小sensor.skip_frames(30) # 让新的设置生效sensor.set_gainceiling(8)clock = time.clock() # 跟踪FPS帧率while(True): clock.tick() # 追踪两个snapshots()之间经过的毫秒数. img = sensor.snapshot() # 拍一张照片并返回图像。 # 使用Canny边缘检测器 img.find_edges(image.EDGE_CANNY, threshold=(50, 80)) #threshold设置阈值 # 更快更简单的边缘检测 #img.find_edges(image.EDGE_SIMPLE, threshold=(100, 255)) print(clock.fps()) # 注意:你的OpenMV摄像头的运行速度只有它的一半 12345678910111213import sensor, image, lcd#初始化摄像头sensor.reset() # 初始化摄像头模块.sensor.set_pixformat(sensor.GRAYSCALE) # 或者使用 sensor.RGB565 彩色sensor.set_framesize(sensor.QQVGA) # 或者使用 sensor.QVGA (or others)sensor.skip_frames(time = 2000) #延时让摄像头文稳定.sensor.set_gainceiling(8) #设置增益，这是官方推荐的参数lcd.init() # LCD初始化while(True): img = sensor.snapshot() # 拍摄并返回图像. #使用 Canny 边缘检测器 img.find_edges(image.EDGE_CANNY, threshold=(50, 80)) lcd.display(img) # LCD显示img 舵机控制 构造函数 classpyb.Servo(id) 创建一个伺服对象。 id 为1-3，与引脚P7至P9相对应。 方法 Servo.angle([angle*, *time=0]) 若未给定参数，该函数返回当前角度。若给定函数，该函数设置servo的角度：angle 是度数计的移动的角度。time 是达到指定角度所用的毫秒数。若省略，则servo会尽快移动到新的位置。 Servo.speed([speed*, *time=0]) 若未给定参数，该函数会返回当前速度。若给定参数，该函数设置servo的速度：speed 是改变的速度，取值100-100。time 是达到指定角度所用的毫秒数。若省略，则servo会尽快加速。 Servo.pulse_width([value]) 若未给定参数，该函数会返回当前的原始脉宽值。若给定参数，该函数设置原始脉宽值。 Servo.calibration([pulse_min*, pulse_max, *pulse_centre[, pulse_angle_90, pulse_speed_100]****]) 若未给定参数，这个函数返回当前的5元组校准数据。若给定参数，该函数设定计时校准：pulse_min 是允许的最小脉宽。pulse_max 是允许的最大脉冲。pulse_centre 是中心/零位置对应的脉宽。pulse_angle_90 是90度对应的脉宽。pulse_speed_100 是速度100对应的脉宽。 串口通信 123456789import timefrom pyb import UARTuart = UART(3, 19200)while(True): uart.write(&quot;Hello World!\\r&quot;) time.sleep_ms(1000) UART类 实例化一个串口， 波特率为19200的串口3 注意：必须是串口3，因为OpenMV2只引出了这个串口，pyb的串口有好多个的。OpenMV3又增加了串口1。 调用write方法传输数据 可传输Json数据","link":"/2022/04/27/OpenMV%E5%AE%9E%E7%8E%B0%E9%9D%B6%E7%82%B9%E6%A3%80%E6%B5%8B/"}],"tags":[],"categories":[]}