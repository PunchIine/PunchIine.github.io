{"pages":[],"posts":[{"title":"Json学习笔记","text":"JSON JSON 语法规则 JSON 名称/值对 JSON 值 JSON 文件 JSON对象 使用点号访问对象值 使用点号. 或者中括号 [] 来访问嵌套的JSON对象。 修改JSON值 修改对象属性 JSON数组 数组可以作为JSON对象 JSON对象中的数组 嵌套 JSON 对象中的数组 Python json json.dumps json.loads JSONJSON: JavaScript Object Notation(JavaScript 对象表示法) JSON 语法规则JSON 语法是 JavaScript 对象表示语法的子集。 数据在名称/值对中 数据由逗号分隔 大括号 {} 保存对象 中括号 [] 保存数组，数组可以包含多个对象 JSON 名称/值对JSON 数据的书写格式是： 1key : value 名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值： “name” : “菜鸟教程” JSON 值JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在中括号中） 对象（在大括号中） null JSON 文件 JSON 文件的文件类型是 .json JSON 文本的 MIME 类型是 application/json MINE类型：媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。 它在IETF RFC 6838中进行了定义和标准化。 JSON对象必须在大括号{}中书写， key必须是字符串，value可以是合法的JSON数据类型（见JSON值） 使用点号访问对象值例： 123var myobj, x;myobj = {&quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null};x = myobj[&quot;name&quot;]; 使用点号. 或者中括号 [] 来访问嵌套的JSON对象。12x = myobj.sites.site1;x = myobj.sites[&quot;site1&quot;]; 修改JSON值使用点号访问并修改 1myobj.sites.site1 = &quot;sxasxaxa&quot; 使用中括号访问并修改 1myobj.sites.[&quot;site1&quot;] = &quot;sadadsad&quot; 修改对象属性使用delete关键字来删除JSON对象的属性： 1delete myobj.sites.site1 JSON数组数组可以作为JSON对象例： 1[ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot; ] JSON对象中的数组例： 12345{&quot;name&quot;:&quot;网站&quot;,&quot;num&quot;:3,&quot;sites&quot;:[ &quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot; ]} 嵌套 JSON 对象中的数组JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象： 例： 123456789myObj = { &quot;name&quot;:&quot;网站&quot;, &quot;num&quot;:3, &quot;sites&quot;: [ { &quot;name&quot;:&quot;Google&quot;, &quot;info&quot;:[ &quot;Android&quot;, &quot;Google 搜索&quot;, &quot;Google 翻译&quot; ] }, { &quot;name&quot;:&quot;Runoob&quot;, &quot;info&quot;:[ &quot;菜鸟教程&quot;, &quot;菜鸟工具&quot;, &quot;菜鸟微信&quot; ] }, { &quot;name&quot;:&quot;Taobao&quot;, &quot;info&quot;:[ &quot;淘宝&quot;, &quot;网购&quot; ] } ]} ————JSON数组和对象都可以使用for-in循环来访问 Python jsonjson.dumps1json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw) ——将python对象编码成JSON字符串 123456import jsondata = [ { 'a' : 1, 'b' : 2, 'c' : 3, 'd' : 4, 'e' : 5 } ]data2 = json.dumps({'a': 'Runoob', 'b': 7}, sort_keys=True, indent=4, separators=(',', ': '))print(data2) json.loads1json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]]) ——json.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。 123456import jsonjsonData = '{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5}';text = json.loads(jsonData)print(text)","link":"/2022/04/10/Json%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"","text":"一.张量1.张量的数据类型 默认数据类型为32位浮点型 **torch.set_default_tensor_type()**函数可设置默认的张量数据类型 a.long() a.int() a.float()方法 2.张量的生成(1)列表或序列可通过**torch.tensor()**函数构造张量 **.shape .size .numel()**方法 1234567a = torch.randn((2,3,5),dtype = torch.float32)print(a.shape)#打印“torch.Size([2,3,5])”不需要加括号，直接访问成员属性，返回的是torch.Size类对象，print(a.shape[1])#可以使用[]索引访问,所以size属性是一个迭代器print(a.size())#打印“torch.Size([2,3,5])”,与shape属性一致print(a.size(1))#可传入参数，返回3，即第i维的个数print(a.numel)#返回30，计算张量中包含元素数量 通过torch.tensor()函数构造张量可使用dtype参数指定数据类型，使用requires_grad来指定是否需要计算梯度 (2)**torch.Tensor()**——————一个类 可以生成指定形状的张量 (3)torch.from_numpy(ndarray) torch.as_tensor() (4)依据数值创建 **torch.empty()**————返回填充有未初始化数据的张量，张量的形状由可变的参数大小定义 1234&gt;&gt;&gt; torch.empty(2, 3)tensor(1.00000e-08 * [[ 6.3984, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000]]) (5)依据概率分布创建张量 **torch.manual_seed()**——————指定生成随机数种子 3.张量的操作（1）张量的拼接与切分 **torch.stack()**会拓展张量维度 （2）张量索引 ==注意index参数的数据类型必须是torch.long== 例 (对第0维度进行索引（相当于索引第一维度）) （3）张量变换 ==注意reshape共享数据内存== 如图： 沿着指定的维度重复tensor。不同与expand()，本函数复制的是tensor中的数据。扩展（expand）张量不会分配新的内存，只是在存在的张量上创建一个新的视图（view），一个大小（size）等于1的维度扩展到更大的尺寸。repeat沿着特定的维度重复这个张量，和expand()不同的是，这个函数拷贝张量的数据。 （4）张量数学运算 真多啊。。。用到再查叭。 二.pytorch中的自动求导将张量的requires_grad参数设为Ture可自动求导得到其梯度 Tensor()类的重要属性： 在Pytorch中，默认情况下，非叶节点的梯度值在反向传播过程中使用完后就会被清除，不会被保留。只有叶子节点的梯度值能够被保留下来 retain_grad()可保存非叶子节点梯度 grad_fn：记录创建该张量时所用的方法（函数） 123print(&quot;grad_fn:&quot;, w.grad_fn, x.grad_fn, a.grad_fn, b.grad_fn, y.grad_fn)# Out：grad_fn: None None &lt;AddBackward0 object at 0x000001C04BB24788&gt; &lt;AddBackward0 object at 0x000001C04605D188&gt; &lt;MulBackward0 object at 0x000001C04605D1C8&gt; autogradtorch.autograd.backward张量中的backward()方法直接调用了torch.autograd.backward() retain_graph参数设置为True，得以进行两次反向传播 grad_tensors参数用于多梯度权重的设置 123456789101112131415161718w = torch.tensor([1.], requires_grad=True) x = torch.tensor([2.], requires_grad=True) a = torch.add(w, x) # retain_grad() b = torch.add(w, 1) y0 = torch.mul(a, b) # y0 = (x+w) * (w+1) y1 = torch.add(a, b) # y1 = (x+w) + (w+1) dy1/dw = 2 loss = torch.cat([y0, y1], dim=0) # [y0, y1] grad_tensors = torch.tensor([1., 1.]) # grad_tensors = torch.tensor([1., 2.]) loss.backward(gradient=grad_tensors) # gradient 传入 torch.autograd.backward()中的grad_tensors print(w.grad) out：7 # 9 torch.autograd.grad create_graph 创建导数计算图，用于高阶求导 autograd小贴士：1.梯度不自动清零 使用grad.zero_() 对梯度清零 2.依赖于叶子节点的节点， requires_grad默认为True 3.叶子节点不可执行in-place操作 可知+=操作时不改变内存地址，为in-place操作，不可对叶子节点执行 三.torch.nn模块容器 卷积层 123456789# 以torch.nn.Conv2d()为例， 介绍卷积再图像上的使用方法，其调用方式为：torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True) 123456789101112131415161718192021222324252627282930import numpy as npimport torchimport torch.nn as nnimport matplotlib.pyplot as pltfrom PIL import Imagemyim = Image.open(&quot;lenna.jpg&quot;)myimgray = np.array(myim.convert(&quot;L&quot;), dtype=np.float32)imh, imw = myimgray.shapemyimgray_t = torch.from_numpy(myimgray.reshape((1, 1, imh, imw)))kersize = 5ker = torch.ones(kersize, kersize, dtype=torch.float32)*-1ker[2, 2] = 24ker = ker.reshape((1, 1, kersize, kersize))conv2d = nn.Conv2d(1, 2, (kersize, kersize), bias = False)conv2d.weight.data[0] = kerimconv2dout = conv2d(myimgray_t)imconv2dout_im = imconv2dout.data.squeeze()plt.figure(figsize=(12, 6))plt.imshow(imconv2dout_im[0], cmap=plt.cm.gray)plt.axis(&quot;off&quot;)plt.show() 可见使用边缘特征提取卷积核很好的提取出了图像的边缘信息 池化层 激活函数 全连接层 四.pytorch中的数据操作与预处理 Dataloader Dataset transforms crop flip rotation transforms的操作 自定义transforms 正态分布与平方损失接下来，我们通过对噪声分布的假设来解读平方损失目标函数。 正态分布和线性回归之间的关系很密切。 正态分布（normal distribution），也称为高斯分布（Gaussian distribution）， 最早由德国数学家高斯（Gauss）应用于天文学研究。 简单的说，若随机变量xx具有均值μμ和方差σ2σ2（标准差σσ），其正态分布概率密度函数如下： (3.1.11) p(x)=12πσ2−−−−√exp(−12σ2(x−μ)2).p(x)=12πσ2exp⁡(−12σ2(x−μ)2). 下面我们定义一个Python函数来计算正态分布。 123def normal(x, mu, sigma): p = 1 / math.sqrt(2 * math.pi * sigma**2) return p * np.exp(-0.5 / sigma**2 * (x - mu)**2) 我们现在可视化正态分布。 12345678# 再次使用numpy进行可视化x = np.arange(-7, 7, 0.01)# 均值和标准差对params = [(0, 1), (0, 2), (3, 1)]d2l.plot(x, [normal(x, mu, sigma) for mu, sigma in params], xlabel='x', ylabel='p(x)', figsize=(4.5, 2.5), legend=[f'mean {mu}, std {sigma}' for mu, sigma in params]) 就像我们所看到的，改变均值会产生沿xx轴的偏移，增加方差将会分散分布、降低其峰值。 均方误差损失函数（简称均方损失）可以用于线性回归的一个原因是： 我们假设了观测中包含噪声，其中噪声服从正态分布。 噪声正态分布如下式: (3.1.12) y=w⊤x+b+ϵ,y=w⊤x+b+ϵ, 其中，ϵ∼N(0,σ2)ϵ∼N(0,σ2)。 因此，我们现在可以写出通过给定的xx观测到特定yy的似然（likelihood）： (3.1.13) P(y∣x)=12πσ2−−−−√exp(−12σ2(y−w⊤x−b)2).P(y∣x)=12πσ2exp⁡(−12σ2(y−w⊤x−b)2). 现在，根据极大似然估计法，参数ww和bb的最优值是使整个数据集的似然最大的值： (3.1.14) P(y∣X)=∏i=1np(y(i)|x(i)).P(y∣X)=∏i=1np(y(i)|x(i)). 根据极大似然估计法选择的估计量称为极大似然估计量。 虽然使许多指数函数的乘积最大化看起来很困难， 但是我们可以在不改变目标的前提下，通过最大化似然对数来简化。 由于历史原因，优化通常是说最小化而不是最大化。 我们可以改为最小化负对数似然−logP(y∣X)−log⁡P(y∣X)。 由此可以得到的数学公式是： (3.1.15) −logP(y∣X)=∑i=1n12log(2πσ2)+12σ2(y(i)−w⊤x(i)−b)2.−log⁡P(y∣X)=∑i=1n12log⁡(2πσ2)+12σ2(y(i)−w⊤x(i)−b)2. 现在我们只需要假设σσ是某个固定常数就可以忽略第一项， 因为第一项不依赖于ww和bb。 现在第二项除了常数1σ21σ2外，其余部分和前面介绍的均方误差是一样的。 幸运的是，上面式子的解并不依赖于σσ。 因此，在高斯噪声的假设下，最小化均方误差等价于对线性模型的极大似然估计。","link":"/2022/04/04/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Git学习笔记","text":"git init —— 初始化一个Git仓库 git add —— 添至暂存区 git commit —— 提交 git push —— 上传远程代码并合并 git pull —— 下载远程代码并合并 git clone —— 从现有Git仓库中拷贝项目 git config —— 配置信息 git status —— 查看仓库当前的状态 显示有变更的文件 git diff —— 比较文件的不同，即暂存区和工作区的差异 git reset —— 用于回退版本， 可以制定退回某一次提交的版本 git rm —— 将文件从暂存区和工作区中删除 git mv —— 用于移动或重命名一个文件,目录或软连接。 git log —— 查看历史提交记录 git remote —— 远程仓库操作 git branch (branchname) —— 创建新分支 git checkout (branchname) —— 切换分支命令 git merge —— 合并分支命令 git fetch —— 从远程获取代码库 git tag [tagname]—— 为提交快照打上标签 生成ssh密钥 git init —— 初始化一个Git仓库 执行后会生成一个.git目录， 该目录包含了资源的所有元数据 使用指定目录作为git仓库 ——git init newrepo 执行后会在newrepo目录下生成.git目录 将文件纳入版本控制 git add —— 添至暂存区git add . —— 将当前目录下所有未纳入的文件添加到暂存区 git add {文件名} —— 将指定文件添加到暂存区 git commit —— 提交git commit -m ‘提交说明’ —— 对暂存区中的文件进行提交（添加到仓库中） git push —— 上传远程代码并合并git push 命用于从将本地的分支版本上传到远程并合并。 命令格式如下： 1git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 若远程分支名与本地分支名相同则可以省略：及之后部分 若版本有差异，想要强制推送 1git push --force &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 若要删除主机的分支 1git push origin --delete master # 表示删除origin主机的master分支 git pull —— 下载远程代码并合并git pull 命令用于从远程获取代码并合并本地的版本。 git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。 命令格式如下： 1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; git clone —— 从现有Git仓库中拷贝项目git clone or git clone ——克隆到指定目录 如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字 git commit -a 跳过git add，直接添加至暂存区后提交 git config —— 配置信息git config –list —— 显示当前的git配置信息 git config -e —— 针对当前仓库编辑git配置文件 git config -e –global —— 针对系统上所有仓库 设置提交代码时的用户信息： git config –global user.name {YOURGITHUBNAME}git config –global user.email {YOUREMAIL} git status —— 查看仓库当前的状态 显示有变更的文件git status -s 获得更简短的输出结果 git diff —— 比较文件的不同，即暂存区和工作区的差异 尚未缓存的改动：git diff 查看已缓存的改动： git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff –stat git reset —— 用于回退版本， 可以制定退回某一次提交的版本1git reset [--soft | --mixed | --hard] [HEAD] git reset HEAD^ - 回退所有内容到上一个版本 git reset HEAD^ {filename} - 回退指定文件到上一个版本 git reset {版本号} - 回退到指定版本 git reset –soft HEAD – soft参数用于回退到某个版本 例： 1$ git reset --soft HEAD~3 # 回退上上上一个版本 git reset –hard HEAD –hard 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交（慎重使用） HEAD 说明： HEAD 表示当前版本 HEAD^ 上一个版本 HEAD^^ 上上一个版本 HEAD^^^ 上上上一个版本 以此类推… 可以使用 ～数字表示 HEAD~0 表示当前版本 HEAD~1 上一个版本 HEAD^2 上上一个版本 HEAD^3 上上上一个版本 以此类推… git reset HEAD 命令用于取消已缓存的内容。 git rm —— 将文件从暂存区和工作区中删除如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f git rm -f 如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可： git rm –cached git mv —— 用于移动或重命名一个文件,目录或软连接。git mv [file] [newfile] git log —— 查看历史提交记录用 –online 选项来查看历史记录的简洁版本。 git log –online git blame - 以列表形式查看指定文件的历史修改记录 git remote —— 远程仓库操作git remote -v —— 显示所有远程仓库 git remote show [remote] —— 显示某个远程仓库的信息 remote为远程仓库地址 git remote set-url [shortname] [url] shortname 为本地的版本库 添加远程版本库： git remote add [shortname] [url] shortname 为本地的版本库 git remote rm name # 删除远程仓库git remote rename old_name new_name # 修改仓库名 git branch (branchname) —— 创建新分支git branch —— 列出本地的分支 git checkout (branchname) —— 切换分支命令当切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 也可以使用 git checkout -b (branchname) —— 创建新分支并立即切换到该分支下，从而在该分支中操作。 git merge —— 合并分支命令git merge [branchname] —— 将指定分支与当前所在分支合并 git fetch —— 从远程获取代码库执行完后执行git merge合并远程分支到你所在的分支 git tag [tagname]—— 为提交快照打上标签例： 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签 git tag —— 查看所有标签 -a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 git log –decorate —— 查看标签 生成ssh密钥执行： 1ssh-keygen -t rsa -C &lt;your email&gt; 会生成一个.ssh文件 找到其中的id_rsa.pub将其中内容复制 进入github settings 点击SSH and GPG keys 创建新密钥并将密钥内容粘贴入其中","link":"/2022/04/10/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"jetson配置日志","text":"jetson nano apt更换国内源备份source.list文件 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 修改source.list文件 1sudo vim /etc/apt/sources.list 删除所有内容，并复制： 12345678deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main multiverse restricted universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main multiverse restricted universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main multiverse restricted universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main multiverse restricted universedeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main multiverse restricted universe 注意arm架构下的apt源与普通的ubuntu不相同 then 12sudo apt-get updatesudo apt-get upgrade jtop安装先安装pip 1sudo apt-get install python3-pip then 1sudo pip3 install jetson-stats -i https://pypi.tuna.tsinghua.edu.cn/simple 1sudo jtop # 打开jtop zerotier安装使用（内网穿透）安装命令 1curl -s https://install.zerotier.com | sudo bash 加入网络 1sudo zerotier-cli join xxxxxxxxxxxxxxxx 离开网络 1sudo zerotier-cli leave xxxxxxxxxxxxxxxx 启动 1sudo systemctl start zerotier-one.service 设置开机自启 1sudo systemctl enable zerotier-one.service minifoege 安装https://github.com/conda-forge/miniforge 在jetson nano中选择Mambaforge时 出现了pip 无法使用 illegal instruction(core dumped) 的问题 安装miniforge后在虚拟环境中出现同样问题， 但能在base环境下正常使用pip 所以选择使用它 在Miniforge-Linux-aarch64.sh所在文件夹打开终端 执行 1bash Miniforge-Linux-aarch64.sh 全yes即可 conda更换国内镜像源配置清华源： 12345conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/#设置搜索时显示通道地址conda config --set show_channel_urls yes 可执行conda config –show channels显示已添加的源 pip更换国内镜像源编辑pip配置文件： 12mkdir ~/.pipvim ~/.pip/pip.conf 添加内容为： 1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn conda更改base环境下python版本1conda install python=&lt;版本号&gt; （看网上都是这么干的， 但由于我们想换版本时已经无意中在base环境下下载了很多包， 所以由于依赖问题这样会报错） 1conda clean -a # 删除所有包 jetson nano 和 jetson nx 配置 cudajetson nano 与 nx 已经内置好了cuda， 但需要配置环境变量才能使用 1vim ~/.bashrc 在.bashrc文件中添加： 1234export PATH=/usr/local/cuda-10.2/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATHexport CUDA_HOME=/usr/local/cuda-10.2export OPENBLAS_CORETYPE=ARMV8 # 据说不加的话，运行相关的项目会内核崩掉（but在我配置nano环境时即使加上也无济于事） 再次执行： 1source ~/.bashrc 最后输入nvcc -V 测试环境变量是否设置正确 cv2, torch等由于numpy问题报错illegal instruction(core dumped)我们下载的numpy版本是1.19.5 在base环境中测试了几个版本发现都没有问题 于是换了个numpy版本就解决了（大概是1.19.5版本的numpy在arm架构下出了点问题） 在linux下使用opencv无法打开摄像头问题[ WARN:0] global /io/opencv/modules/videoio/src/cap_v4l.cpp (893) open VIDEOIO(V4L2:/dev/video0): can’t open camera by index发现是重复调用摄像头导致的： 两次使用了cv2.VideoCapture(0) 删去一个就可以了 除此之外还遇到了另一个报错令代码无法运行（忘记记录了），原因是opencv版本太高， 降了几个版本就解决了 报错This plugin does not support propagateSizeHints()， 图形界面控件消失网上的解决方案都奇奇怪怪的（我看不明白） 在使用管理员权限运行代码后神奇的成功了 sudo python main.py pyside2的安装在网上没有找到支持arm架构的pyside2 whl安装包 所以我们自己编译了pyside2 dlib安装torch和torchvision的安装","link":"/2022/04/16/jetson%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97/"}],"tags":[],"categories":[]}